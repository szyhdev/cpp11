第一章 新标准的诞生

一、曙光：C++11标准的诞生
  1、C++11/C++0x（以及C11/C1x）——新标准诞生
  2、什么是C++11/C++0x
  3、新C++语言的设计目标
二、今时今日的C++
  1、C++的江湖地位
  2、C++11语言变化的领域
三、C++11特性的分类
四、C++特性一览
  1、稳定性和兼容性之间的抉择
  2、更倾向于使用库而不是扩展语言来实现特性
  3、更倾向于通用的而不是特殊的手段来实现特性
  4、同时支持新手和专家
  5、增强类型的安全性
  6、增强代码执行性能和操作硬件的能力
  7、开发能够改变思维方式的特性
  8、融入编程现实
五、本书的约定
  1、关于一些术语的翻译
  2、关于代码中的注释
  3、关于本书中的代码示例与实验平台

- 从最初的C++0x到最终的C++11，C++的第二个真正意义上的标准姗姗来迟
- 可以想象，这个迟来的标准必定遭遇了许多困难，C++标准委员会应对这些困难的种种策略，构成了新的C++语言的基因
- 本章会从设计思维和应用范畴两个维度对所有的C++11新特性进行分类，一览C++11的全景

一、曙光：C++11标准的诞生

1、C++11/C++0x（以及C11/C1x）——新标准诞生

- 2011年11月，在印第安纳州布卢明顿市，“八月印第安纳大学会议”落下帷幕
  * 这次会议的结束意味着长期以来以C++0x为代号的C++11标准终于被C++标准委员会批准通过
  * 从C++98标准通过开始，C++标准委员会（即，WG21）已经为新标准工作了11年多的时间
  * 期间经历了面向对象编程的盛极时刻，见证了泛型编程的风起云涌，还见证了C++之后各种新的流行编程语言的诞生

- 事实上，在2003年WG21曾提交了一份技术勘误表（Technical Corrigendum），简称TC1
  * 这次修订使得C++03代替C++98成为C++11之前的最新的C++标准的名称
  * 不过，由于这份技术勘误表主要是对C++98中的漏洞进行修复，核心语言规则并没有改动，因此，人们习惯于把这两个标准合称为“C++98/03”

-------------------------------------------------------------------------------------------
- 在本书中，当C++98和C++03没有差异时，都会使用C++98/03来表示它们，甚至直接简写为C++98
- 如果涉及TC1中提出的微小差别，则会使用C++98和C++03分别指代两个标准
-------------------------------------------------------------------------------------------

- C++11是一种新语言的开端
  * 和C++03相比，C++11带来了数量可观的变化，这包括约140个新特性以及对C++03中约600个缺陷的修正
  * 从这个角度看，C++11更像是从C++98/03孕育出的一种新语言，它引入了大量的新特性，使C++的面貌焕然一新
  * 这些全新的特性和概念，是本书要详细描述的内容

2、什么是C++11/C++0x

- C++0x是WG21计划取代C++98/03的新标准的代号
  * 这个代号是在2003年取的，当时C++标准委员会乐观地估计新标准会在第一个十年内完成
  * 但到2010年新年时，WG21内部还在为哪些特性该放弃、哪些特性该消减等议题而争论，于是，新标准没能准时发布
  * 乐观的委员会开玩笑说，x应该是一个十六进制数，所以还有6年的时间，最终，他们“提前”四年完成了C++11标准

-------------------------------------------------------------------------------------------
- C标准委员会（即，WG14）几乎也在同时致力于取代C99标准，他们对标准完成时间的预期更加现实，在2011年通过了提案，这就是C11标准
-------------------------------------------------------------------------------------------

- C++发展编年史【表1-1】
  * 1990年：The Annotated C++ Reference Manual出版，描述了C++核心语言，但没有涉及库
  * 1998年：第一个国际化的C++标准，IOS/IEC 15882:1998，包括核心语言、STL、locale、iostream、numeric、string等特性
  * 2003年：第二个国际化的C++标准，IOS/IEC 15882:2003，核心语言和库与C++98保持一致，但包括了技术勘误表，这就是C++03
  * 2005年：技术报告IOS/IEC TR 19768:2005，即，TR1，核心语言不变，包括了14个可能进入新标准的C++新程序库
  * 2007年9月：SC22注册表决，通过了C++0x中的核心特性
  * 2008年9月：SC22委员会草案表决，基本上完成了C++0x中所有的核心特性，包括了13个源自TR1的库及70个库特性，修正了约300个库缺陷
  * 2010年3月：SC22最终委员会草案表决，所有的核心特性都已完成，处理了各国代表的评议
  * 2011年11月：JTC1 C++11最终国际化标准草案发布，即，IOS/IEC 15882:2011，核心语言和库都进行了很大的改进，包括了TR1中的大部分内容
  * 2012年2月：在ANSI和ISO商店可以买到最新的C++11标准

-------------------------------------------------------------------------------------------
- 语言标准的发布通常有两种，规范的和不规范的
  * 前者表示内容通过了批准，因此是正式的标准，后者则不是
  * 但后者（比如，前面提到的技术报告TR1）通常具有积极的意义，可以推动标准的发展，并可能成为最终标准的一部分
-------------------------------------------------------------------------------------------

- 图1-1比较了WG21和WG14两个标准委员会制定新标准的工作进程【图1-1】

3、新C++语言的设计目标

- C++98/03的设计目标
  * 比C语言更适合系统编程（且与C语言兼容）
  * 支持数据抽象
  * 支持面向对象编程
  * 支持泛型编程
- 这些特点使得面向对象编程和泛型编程在过去的10~20年中成为编程界的明星
  * C++的发展不仅仅是依靠学者的前瞻远见推动的，有时也会借助机缘巧合，比如C++模板，它使得C++几乎成为一种函数式编程语言
  * 另一方面，基于一些“后见之明”，有些较为激进的特性，比如，动态异常处理、输出模板等，在C++11中被弃用了

- C++11的设计目标
  * 使得C++成为更好的适用于系统开发和库开发的语言：不只是注重为某个特定领域提供专业化功能，而是希望对各种系统的开发都能做出贡献
  * 使得C++成为更易于教学的语言（即，语法更加一致化和简单化）：修复了一些让程序员不安的语言毒瘤，使新手更容易上手，同时，语言的复杂部分又能够满足特定人员的需求
  * 保证语言的稳定性以及和C语言、C++03的兼容性：排除了许多无关的特性，防止C++成为一门千头万绪但功能互不关联的语言，毕竟实用性是一门伟大语言长期存活的基础

- 在取舍新语言特性方面，C++标准委员会面临了巨大的压力，但与此同时，标准委员会并没有收集到足够多的库的新特性
  * 作为一门通用型语言，C++是否成功通常依赖于它在不同领域中的使用情况，在目前的标准库中，服务于各个领域的新特性还是太少了
  * 在下一个C++标准的制定中，如何标准化地使用库将会成为热门话题，标准委员会已准备好接受来自这方面的压力

二、今时今日的C++

1、C++的江湖地位

- 如今，C++仍然位列通用编程语言前三甲，不过似乎没有以前流行了
  * C++的应用领域很广泛，包括教授课程、控制电子设备、开发智能手机、编写搜索引擎、构建游戏引擎等
  * 在构建致力于沟通软硬件的系统编程中，C++也常常是必不可少的
  * C++甚至还常常被用于设计和编写其他编程语言
- 评价编程语言的标准应该包括数量、新颖性、质量以及上述多个方面，可以说，C++仍然无处不在

2、C++11语言变化的领域

- 和C++98/03相比，C++11大大缩短了代码编写量，根据具体情况可以缩短30%~80%
- C++11的增强
  * 通过内存模型、线程、原子操作等来支持原生并行编程（Native Concurrency）
  * 通过统一初始化表达式、auto、decltype、移动语义来统一对泛型编程的支持
  * 通过constexpr、POD等更好地支持系统编程
  * 通过内联名字空间、继承构造函数、右值引用等更好地支持库的构建

- C++11的语言特性【表1-2】
  * 这是一张很长的语言特性列表，和C++98/03相比，C++的确像是一门新语言
  * C++11是一个编程语言范型联盟，支持面向对象编程、过程式编程、泛型编程、函数式编程、元语言编程等
  * 多范型的支持使得C++11的硬能力在编程语言中几乎无出其右

- 程序员常常需要对实物、流程、概念等进行抽象描述，同时还需要对类型、类型的类型、算法甚至资源的生命周期进行抽象描述，这些都是C++可以做到的
  * 在C++11中，这些抽象概念常常被实现在库中，其使用比在C++98/03中更加方便好用
  * 从这个角度讲，C++11是一种“轻量级抽象编程语言”，这样，程序员可以把程序设计的重点放在设计和实现的运用上

- 总的来说，灵活的静态类型、小的抽象概念、绝佳的时间和空间运行性能以及与硬件紧密结合的工作能力都是C++11的亮点
  * 反观C++98/03，其最强大的能力体现在能够构建软件基础架构或构建资源受限/不受限的项目上
  * 从这个意义上，C++11是C++在编程语言领域上的一次泛化和进步

- 大多数编译器已经开始对C++11的支持
  * 有三款编译器从2008年就开始支持C++11了，IBM的XL C/C++编译器从版本10.1开始，GNU的GCC编译器从版本4.3开始，而英特尔的编译器从版本10.1开始
  * 微软则是从Visual Studio 2010开始支持C++11的新特性
  * 最近，苹果的clang/llvm也从2010年的版本2.8开始支持C++11的新特性

三、C++11特性的分类

- 从设计目标上说，能够让各个特性协同工作是设计C++11/0x最关键的部分，也是最困难的部分
- 因此，相对于其他各种考虑，WG21更专注于以下理念
  * 保持语言的稳定性和兼容性
  * 更倾向于使用库而不是扩展语言来实现特性
  * 更倾向于通用的而不是特殊的手段来实现特性
  * 同时支持新手和专家
  * 增强类型的安全性
  * 增强代码执行性能和操作硬件的能力
  * 开发能够改变思维方式的特性
  * 融入编程现实
- 根据这些设计理念，可以对C++11的新特性进行分类，本书的第二~八章正是按照这个分类划分的

- 而从使用上，Scott Mayers创建了另外一种分类方式
  * 他根据使用者是类的使用者还是库的使用者，或者特性是广泛使用的还是对库的增强来进行分类
  * 具体包括类作者、库作者、所有人、部分人
- 表1-3通过设计理念和用户群对C++11的新特性进行分类【表1-3】

- 由于C++11的特性非常多，本书不打算涵盖所有的内容
  * C++11的特性粗略地可以分为核心语言特性和库特性，C++11标准中的第1~16章是核心语言特性部分，第17~30章是库特性部分，本书不打算描述标准库
  * 虽然不会对标准库进行描述，但对于和核心语言特性相关的库内容，还是会描述的

- 对于那些“更倾向于使用库而不是扩展语言来实现的特性”，可能会放到另一本书中进行讲解
- 库特性主要包括算法增强、容器增强、分配运算符、std::array、std::forward_list、无序容器、std::tuple、类型特性、std::function和std::bind、unique_ptr、shared_ptr、weak_ptr、线程、互斥、锁、条件变量、时间工具、std::future和std::promises、std::async、随机数、正则表达式

四、C++特性一览

- 接下来会了解一下C++11中各种特性的来历、用途和特色
- 如果理解时有困难，读者可以在读完全书后再回到这里，这里是对全书最好的总结

1、稳定性和兼容性之间的抉择

- 通常在语言设计中，不破坏现有的代码和增加新的能力，这二者是需要同时兼顾的
- 语言的设计者如果完全不考虑兼容性，那将是一个丑陋的做法，因为来自习惯的力量总是超乎人的想象
  * 通过谷歌代码搜索可以查看关键字是否被开源代码频繁地使用，不过这仅限于开源代码
  * WG21中的很多企业代表，可以帮助确定关键字是否会导致自己企业的代码库出现不兼容的问题

- C++11中新定义的关键字包括alignas、alignof、decltype、auto、static_assert、using、noexcept、export、nullptr、constexpr、thread_local
  * 这些关键字可能会破坏现有的C++98/03的代码，比如，static_assert，尽管WG21尽量把它设计得很长，但也许程序员已经定义了一个同名的函数
  * C++11中还有两个具有特殊意义的标识符，final和override，它们只有在成员函数的后面时才有特殊意义，不过，程序员可能已经定义了同名的变量

2、更倾向于使用库而不是扩展语言来实现特性

- 相对于核心语言特性的稳定，库总是能随时为程序员提供快速上手的、方便易用的新功能
  * 库的能量是巨大的，Boost、Qt等的快速成长就说明了这一点
  * 而且，库还有一个优势是，库的改动不需要编译器实现新特性
  * 更重要的是，库可以用来支持不同领域的编程

- 狂热的语言爱好者总是认为只有将功能加入语言特性才是王道，但WG21会尽量将语言特性通过库来实现
  * C++11中的线程被实现为库的一部分，std::thread
  * C++11中没有关联数组类型，而是在库中实现为std::unordered_map等
  * C++11中也没有其他语言核心功能中的正则表达式功能，而是实现为库中的std::regex

- 传统意义上，库可能是通过提供头文件来实现的，当然有时也会被实现在二进制代码库中
- 但并非所有的库都是通过这样的方式提供的，库也可能实现于编译器内部，比如，C++11中的原子操作
  * 编译器会在内部将原子操作实现为具体的机器指令，而无需链接实实在在的库
  * 本书将原子操作放在库部分来讲解，是为了满足将原子操作作为库实现的自由

3、更倾向于通用的而不是特殊的手段来实现特性

- WG21希望通过通用的手段而不是加入单独特性的方式来练成C++11的十八般武艺
- 显式类型转换操作符是一个很好的例子
  * C++98/03中可以通过为构造函数加上explicit关键字来将构造函数声明为显式构造
  * 但构造函数并不是唯一会产生隐式类型转换的地方，类型转换操作符也可以发生隐式类型转换，这是C++98/03中的疏忽
  * C++11中可以将类型转换操作符指定为显式转换
- 其他一些新特性，比如继承构造函数、移动语义等也是如此

4、同时支持新手和专家

- 如果C++只是适合专家的语言，那它就不可能是一门成功的语言
  * C++中有许多专家级的特性，但并不是必须学习的
  * 通常，程序员只需要学习一定的知识就可以使用C++

- 在C++11中，从易用的角度出发，修缮了许多特性，比如，一度被群起而攻之的双右尖括号
  * C++98/03采用了最长匹配的解析规则，因此会将“模板的模板”识别为右移运算符，从而抛出一条错误信息
  * C++11中对此进行了修正，两个右尖括号会终结模板参数，不会导致编译错误

- 另一个C++11中易于上手的特性是统一的初始化语法
  * C++继承了C语言中的“集合初始化语法”，但在设计类时，只定义了形式单一的构造函数的初始化语法
  * 在C++98/03中编写模板时，这会带来障碍，因为模板作者无法知道模板用户会使用哪种类型来初始化模板
  * 在C++11中，统一的初始化语法使得模板作者总是可以在模板编写时采用集合初始化（即，初始化列表）
  * 而且，集合初始化还对类型收窄做出了一定的限制，这样，C++11的初始化列表就同时拥有了泛型编程和防止类型收窄的双重好处

5、增强类型的安全性

- 绝对的类型安全对编程语言来说几乎是不可能达到的，不过在编译时期捕捉更多的错误是有益的
  * 在C++98/03中，枚举会退化为整型，常常会和其他枚举混淆，这部分来源于兼容C语言
  * 在C++11中，标准引入了强枚举类型来解决这个问题

6、增强代码执行性能和操作硬件的能力

- 在C++编程中，嵌入式编程是一个重要的领域
  * C++11中的常量表达式和原子操作都是可以支持嵌入式编程的重要特性
  * 这些特性对于提高性能、降低存储空间都大有好处

- C++98/03中也有const类型，但它对只读内存（ROM）支持得不够好
  * const类型只有在初始化后才意味着它的值是常量，并且在运行时不可改变
  * 由于这个初始化过程仍然是动态的，这对ROM设备不太适用
- 为此，C++11增加了constexpr，它使得函数和变量可以被编译时的常量取代
  * 从效果上说，函数和变量在固定内存设备中要求的空间就会变少
  * 因此，C++11对手持、桌面等小型嵌入式设备支持得更好

- C++11甚至提供了直接操作硬件的方法，这就是原子类型
  * C++11通过引入内存模型，为开发者提供了一个高效的同步机制
  * 作为开发者，通常需要保证多线程程序能够正确同步，系统则要保证开发者使用原子类型编写的程序不会引入数据竞争
  * 为了同步，系统会自动地禁止某些优化，对程序员来说，这个过程基本上是透明的
- 就算程序员不愿意使用原子类型，而是使用线程，通常使用标准的互斥量进行临界区的加锁和解锁就可以满足要求了
- 如果还希望进一步挖掘并行的速度，试图完全控制底层，无锁的原子类型也可以满足这种需要，内存模型机制会保证不会出错
- 只有在使用与系统内存单位不同的位域时，内存模型才无法保证同步
  * 像struct { int a:9; int b:7; }这样的位域常常会引发竞争，因为它跨一个内存单元，破坏了内存模型的假定
  * 像struct { char a; char b; }这样的位域则不会引发竞争，因为字符位域可以被视为独立的内存位置，不过在C++98/03的多线程中这样写仍然会引发竞争，原因是在单线程下被视为安全的优化在多线程下却可能发生错误，C++11则没有这方面的问题
- 与硬件紧密合作的能力使得C++可以在任何系统编程中保持领先的位置，包括设备驱动、操作系统内核以及金融、游戏这些需要高性能后台守护进程的应用

7、开发能够改变思维方式的特性

- lambda函数其实只是对C++98/03中带有operator ()的局部仿函数包装后的“语法甜点”
  * 在C++11中，lambda函数被处理为匿名的仿函数
  * 当创建lambda函数时，编译器会在内部生成一个匿名的仿函数，并从其父作用域内取出参数传递给它
- 但真正改变人们的思维方式的是，lambda函数是一个局部函数
- 当程序员越来越多地使用C++11中的并行特性时，lambda会成为一个非常重要的语法

- 另一个改变人们思维方式的是，如何让一个成员函数变得无效
  * C++98/03中的惯用方法是将成员函数声明为私有
  * C++11中则可以通过显式默认和删除的特性，清楚明白地将成员函数设置为删除的

8、融入编程现实

- 现实世界的编程往往都有特殊的需求
  * 在访问互联网时常常需要输入URL，其中包含“/”，这需要转义字符的配合，以避免它被误认为是除号
  * C++11中的原生字符串可以免除转义的需要，帮助程序员清晰地呈现网络地址或文件目录

- 如今，GNU的属性无处不在，所有的编译器都尝试支持它，以便修饰类型、变量、函数等，因此，C++11引入了通用属性
- 不过，C++11引入通用属性的更大原因是，属性可以在不引入额外关键字的情况下，为编译提供额外的信息
  * 一些可以实现为关键字的特性，也可以用属性来实现
  * 在现有的情况下，通用属性不能破坏已有的类型系统，也不应该在代码中引起歧义
  * 因此，C++11最终选择了很少的几个通用属性，noreturn和carrier_dependency，其实，final和override曾一度是热门人选
- 属性的真正强大之处在于它能够使编译器供应商创建自己的语言扩展，同时不干扰语言的标准化，相当于用于一定域内的方言

五、本书的约定

1、关于一些术语的翻译

- 在已有翻译且翻译已被广为接受的情况下，继续使用已有的翻译，比如模板
- 在已有翻译但翻译并未被广为接受的情况下，考虑保留原来的英文，比如URL
- 对于还没有被广泛接受的翻译，会采取审慎的态度
  * 如果英文确实有利于理解，会保留英文，并尝试以注释的方式提供一个中文的解释
  * 如果翻译成中文更利于理解，则会提供一个中文翻译，并在注释中保留英文

2、关于代码中的注释

- 在本书中，会将一些标准输出/标准错误的内容放在代码的注释中
- 同时，一些关键的、有助于读者理解的解释也会放在代码的注释中

3、关于本书中的代码示例与实验平台

- 在本书的编写中，使用了三种编译器，IBM的XL C++、GNU的g++以及llvm的clang++
  * XL C++是开发中的版本13
  * g++是开发中的版本4.8
  * clang++是开发中的版本3.2

- 本书中的代码大多数为作者原创，少量采用了C++11标准提案中的案例以及一些网上的资源
  * 在编写本书时，还没有编译器提供对C++11的完整支持，对于代码的编译将以g++为主，但这并不意味着其他编译器无法编译这些代码
  * 使用相同特性的代码，不同编译器的支持往往并不存在很大的个体差异，这正是设立标准的意义所在

- 代码运行的平台
  * 运行在IBM Power服务器上的SUSE Linux Enterprise Server 11的虚拟机
  * 运行在IBM Power5+服务器上的SUSE Linux Enterprise Server 10 SP2的虚拟机

<2022-9-24>
