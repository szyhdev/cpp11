第五章 提高类型安全

一、强类型枚举
  1、枚举：分门别类与数值的名字
  2、有缺陷的枚举类型
  3、强类型枚举以及C++对原有枚举类型的扩展
二、堆内存管理：智能指针与垃圾回收
  1、显式内存管理
  2、C++11中的智能指针
  3、垃圾回收的分类
    1）基于引用计数
    2）基于跟踪处理
  4、C++与垃圾回收
  5、C++11与最小垃圾回收支持
  6、垃圾回收的兼容性
三、小结

- 和C语言相比，C++更强调类型，目的是为了在构建复杂的软件系统时，能够尽可能在编译时找到错误并提醒程序员
  * 虽然C++98在类型构建方面已经近乎完美，但枚举仍然是漏网之鱼，C++11对其进行了增强
  * 另一方面，指针的安全一直是C++的重要议题，C++11再次为此做出了努力

一、强类型枚举

【类别：部分人】

1、枚举：分门别类与数值的名字

- 枚举类型是C/C++中一个基本的内置类型
  * 从枚举的本意上讲，它就是为了定义一个类别，并穷举该类别下的所有取值以供使用
  * 由于枚举来源于C语言，出于设计简单的考虑，枚举值常常是对应到整型数值的一些名字
- 枚举类型也可以是匿名的，匿名的枚举会有意想不到的用处

- 程序中需要通过名字使用数值时，一般有三种做法
  * 宏：宏的弱点是它只是预处理阶段的名字，容易干扰其他正常的代码，所以一般使用大写以示区分
  * 匿名枚举：匿名枚举中的名字都是编译时的名字，可以得到编译器的检查，它不会像宏那样干扰其他正常的代码
  * 静态常量：这是C++中推荐的方法，它同样会接受编译器的检查，而且作用域被限制在文件内，和匿名枚举相比，它不仅仅是编译时的一个名字，还会增加一点儿存储空间，相比而言，匿名枚举似乎更好用
- 事实上，这三种方式孰优孰劣，程序员们各执一词

-------------------------------------------------------------------------------------------
- 在历史上，枚举还有一种被称为“enum hack”的独特应用，因为在某些编译器上不能对静态常量就地赋值（即，只能在class的声明之外对静态常量赋值），因此，有人采用了在类的声明中定义枚举的方式来代替静态常量
-------------------------------------------------------------------------------------------

- 尽管存在这些略显奇怪的用途，不过作为类型而言，enum是不完美的

2、有缺陷的枚举类型

- C/C++中的枚举有一个奇怪的设定，具名的枚举类型的名字及其成员的名字是全局可见的
  * 这和C++中的namespace、class、struct、union等必须通过“名字::成员名”的方式来进行访问格格不入，因此，枚举被称为“非强作用域类型”
  * 这意味着不同枚举类型中的相同名字会产生冲突，导致编译错误

- 虽然使用namespace可以分隔全局空间，但namespace内部的成员依然会被枚举类型的成员污染，一不小心就可能出错【代码清单5-1】
  * Category在一个匿名namespace中，因此，它的所有成员都会默认进入全局名字空间，一旦程序员忘记使用名字空间T，就可能导致错误的结果
  * 此时，有的编译器会发出警告，但不会阻止编译，有的编译器则不会发出任何警告

- 枚举的成员总是可以被隐式转换为整型，有时候这也是不安全的【代码清单5-2】
  * 程序员错误地将Type枚举值与Category枚举值进行比较，由于枚举值被隐式转换为整型，比较运算得以正常进行
  * 有的编译器会警告在不同的枚举值之间进行了比较，但不会停止编译，因为C++标准并不阻止这一点

- 为了解决上面的问题，一般会对枚举类型进行封装【代码清单5-3】
  * 简单地说，就是使枚举类型成为类的成员，并为每个枚举类型的成员定义一个类的静态常量
  * 由于类中的数据不能被默认转换为整型，所以可以避免隐式转换
  * 同时，通过封装，枚举的成员不再会污染全局空间了，使用时必须带上类的名字
- 不过，这个解决方案并非完美，至少存在三个缺点
  * 程序员一般不会为了简单的枚举做如此复杂的封装
  * 由于封装并定义了静态常量，原来属于POD的枚举类型成为非POD的了，这会带来不必要的损失
  * 大多数系统的ABI（应用程序二进制接口）规定，如果参数是个结构体，就不能像整型那样通过寄存器传递，只能通过栈来传递，所以，枚举被封装到类中以后，会带来一定的性能损失

- 此外，枚举类型所占的空间大小也是个不确定量，C++标准规定，枚举所基于的基础类型是由编译器决定的，这会导致基础类型的不确定性，尤其是符号问题【代码清单5-4】
  * 不同的编译器会对枚举类型应用不同的数据长度，比如，普通的枚举使用4字节的内存，必要时可以拓展为8字节
  * 不同的编译器会对枚举的成员使用不同的基础类型，比如，Visual C++会使用无符号整型，而g++则会根据具体情况进行变动

3、强类型枚举以及C++对原有枚举类型的扩展

- 非强作用域类型、允许隐式转换为整型、占用的存储空间和符号的不确定，这些都是枚举的缺点
- 针对这些缺点，C++11引入了新的枚举类型，即，枚举类，又称为“强类型枚举”
- 声明强类型枚举很简单，在原有的关键字enum后面加上关键字class即可
- 强枚举类型的优势
  * 强作用域：强类型枚举的成员的名字不会被输出到父作用域空间
  * 转换限制：强类型枚举的成员的值不能与整型隐式地相互转换
  * 可以指定基础类型：默认为int，但也可以显式指定其他类型，只需要在枚举名称后面加上冒号和类型即可，类型可以是除wchat_t之外的任何整型

- 使用强类型枚举【代码清单5-5】
  * 两个强类型枚举包含同名的成员，但由于这些成员不会输出到父作用域，所以避免了名字冲突的问题，不会引起编译错误
  * 使用强类型枚举的成员时，必须加上所属的枚举类型的名字
  * 强类型枚举的成员之间仍然可以进行数值比较，但不能隐式转换为整型，这使得枚举更符合它的本意，即，对同类进行列举的一个集合，而定义它与数值之间的关联只是为了能够拥有一种对成员进行排序的机制
  * 新的强类型枚举避免了原有枚举类型的缺陷，也没有将枚举类型封装成类的缺点
- 同时，强类型枚举仍然是POD的，不会像类封装版本那样被视为结构体而造成不必要的损失
- 由于可以指定基础类型，可以避免因为编译器不同而导致的不可移植的问题

- 通过设置较小的基础类型还可以节省内存空间【代码清单5-6】
  * 对于强类型枚举C，由于它只有两个较小的取值，一个char就足以保存所有的成员
  * 对于强类型枚举D，指定其基础类型为unsigned int，则所有的编译器都会使用unsigned int来保存该枚举，从而产生一致的输出

- 相比于原有的枚举，强类型枚举更像是一个属于C++的枚举
- 为了配合新的强类型枚举，C++对原有枚举类型进行了扩展
  * 原有的枚举类型在默认情况下仍然由编译器指定具体的实现，但也可以像强类型枚举那样指定除wchar_t之外的整型
  * 原有的枚举类型在默认情况下仍然会输出到父作用域，但在枚举类型的作用域内也是有效的
  * 这两个扩展都保持了向后兼容，以方便程序员在代码中同时操作新旧两种枚举类型

- 在声明强类型枚举时，也可以使用关键字enum struct
  * 事实上，enum class和enum struct在语法上没有任何区别
  * enum class的成员没有公有或私有之分，也不会使用模板来支持泛化的声明

- 比较有趣的是匿名强类型枚举，由于它是强类型的，匿名的enum class恐怕什么也做不了，这和匿名的struct是不一样的【代码清单5-7】
  * 定义了一个匿名枚举类型的实例，却无法为其赋值或比较其值，这和匿名的struct是不一样的
  * 事实上，使用enum class时应该总是为它提供一个名字

二、堆内存管理：智能指针与垃圾回收

【类别：类作者、库作者】

1、显式内存管理

- 如果程序没有正确处理内存的分配和释放，常常会出现以下问题
  * 野指针：内存已被释放但指向它的指针还在被使用
  * 重复释放：试图释放已经被释放或者已经被重新分配的内存
  * 内存泄漏：不再使用的内存始终没有被释放
- 虽然显式内存管理在性能上有一定的优势，但容易出错，替代的方法是使用智能指针
- 在C++11中，智能指针被进一步改进，同时，标准库还提供了所谓“最小垃圾回收”的支持

2、C++11中的智能指针

- 在C++98中，智能指针通过auto_ptr来实现
  * auto_ptr以对象的方式管理在堆上分配的内存，在适当的时间释放所获得的内存
  * 但它有一些缺点，比如，拷贝时返回一个左值、不能用于数组指针等，所以，在C++11中被废弃了

- C++11改用unique_ptr、shared_ptr和weak_ptr来自动回收堆内存【代码清单5-8】
  * unique_ptr、shared_ptr和weak_ptr都实现了operator *，通过它可以访问其拥有的指针的内容
  * get成员函数则用来获得其拥有的指针，所以，operator *相当于*get()
  * 同时，它们都提供了reset成员函数，用来显式释放其拥有的指针

- 从作用上讲，unique_ptr和shared_ptr与以前的auto_ptr保持一致
- 当然，unique_ptr和shared_ptr在所持有的内存的共享方面还是有一定区别的

- unique_ptr意味着其拥有所指向的指针的所有权，所以，unique_ptr无法复制
  * 直接复制unique_ptr会引起一个编译错误，这种“所有权”只能通过标准库的std::move函数来转移
  * std::move函数用来将一个左值转换为右值，进而可以实现所有权的转移
  * 从实现上讲，unique_ptr是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型
  * 程序员只能通过右值来构造unique_ptr，构造完成后，右值就失去了对原指针的所有权

- shared_ptr用于共享地拥有指针，允许多个智能指针拥有同一份在堆上分配的内存
  * 一个shared_ptr放弃对指针的所有权并不影响其他的shared_ptr
  * 当所有拥有指针的shared_ptr都放弃对指针的所有权时，指针才会被释放
  * shared_ptr的实现使用了引用计数，只有当引用计数归零时，它指向的内存才会真正被释放

- 除了unique_ptr和shared_ptr之外，weak_ptr可以用来指向shared_ptr所指向的指针，但不对其拥有所有权，也不影响其引用计数
  * lock成员函数用来返回weak_ptr指向的shared_ptr
  * 当所有拥有指针的shared_ptr都放弃了对指针的所有权时，weak_ptr不再有效，此时，lock返回nullptr
  * 简单地说，可以通过weak_ptr来使用指针，但它并不参与对指针的管理

- weak_ptr可以用来检验shared_ptr的有效性【代码清单5-9】
  * 当两个shared_ptr对象都有效时，调用weak_ptr的lock成员函数将返回一个有效的shared_ptr对象以供使用
  * 当调用两个shared_ptr对象的reset成员函数之后，weak_ptr的lock成员函数返回一个nullptr
  * 在整个过程中，只有shared_ptr参与了引用计数，而weak_ptr对引用计数没有影响

- 一般来说，unique_ptr用来取代auto_ptr，而shared_ptr和weak_ptr根据情况用于需要引用计数的地方
- 虽然这些智能指针能够帮助程序员进行有效的堆内存管理，但还是需要显式地使用它们，而完全不需要考虑回收指针类型的内存管理方案会更受欢迎，这就是“垃圾回收机制”

3、垃圾回收的分类

- 显式内存管理的替代方法很早就有了，1959年前后，John McCarthy为Lisp语言发明了所谓“垃圾回收”的方法
  * 所谓“垃圾”，是指之前使用过的但现在不再使用或者没有指针再引用的内存空间
  * 所谓“垃圾回收”，是指把这些“垃圾”收集起来以便再次利用的机制
- C不支持垃圾回收机制，C++只提供部分支持，但随着编程语言的发展，很多编程语言都提供了对它的支持，比如，Java、C#、Python等

- 垃圾回收的方式很多，但主要分为两类，基于引用计数或者基于跟踪处理

1）基于引用计数

- 基于引用计数的垃圾回收通过系统记录对象被引用的次数，当引用次数变为0时，该对象就可以被回收
- 这种方式实现简单，不会造成程序暂停，也不会对系统的缓存或者交换空间带来冲击
- 但这种方式比较难于处理“环形引用”的问题，并且由于计数带来的额外开销也不小，所以在实用上有一定的限制

2）基于跟踪处理

- 和基于引用计数相比，基于跟踪处理的垃圾回收被更为广泛地应用
- 基于跟踪处理的垃圾回收算法主要有三种，标记-清除、标记-整理和标记-拷贝

- 标记-清除
  * 将程序正在使用的对象视为根对象，查找它们所引用的堆空间并做标记，所有没有被标记的对象被认为是垃圾对象，在清除阶段被回收
  * 这种方法的特点是，仍在使用的对象不会被移动，会出现大量内存碎片

- 标记-整理
  * 这种算法和标记-清除类似，但在做完标记之后，不是回收不再使用的对象，而是把仍在使用的对象向左对齐，这就解决了内存碎片的问题
  * 这种方法的特点是，仍在使用的对象会被移动，因此，程序中所有对堆内存的引用都必须更新

- 标记-拷贝
  * 这种算法把堆空间分为两个部分，From和To，当From分配满时，把From中所有仍在使用的对象复制到To中并紧凑排列，然后互换From和To的角色，开始新的分配
  * 这种方法的问题是堆空间的利用率只有一半，而且也需要移动仍在使用的对象，从某种意义上讲，它是标记-整理的另一种实现

- 虽然C++历来没有公开支持过垃圾回收机制，但C++11已经开始对垃圾回收做出一定的支持，可以看出C++正在变得更强大

4、C++与垃圾回收

- 尽管智能指针通过引用计数能够有效管理内存，但形如“环形引用”这样的问题会限制它的使用，而且还有多线程程序引起的内存管理上的困难，因此，程序员有时候会需要垃圾回收
- 一些第三方的C/C++库已经支持标记-清除的垃圾回收，比如Boehm，它使用专门的堆内存分配函数来代替malloc，由垃圾回收器来管理内存并回收垃圾，不过这种库在实际使用中会有一些限制，可移植性也不好
- 为了解决垃圾回收中的安全性和可移植性问题，Boehm和赛门铁克向C++委员会递交了一个垃圾回收的提案，这就是C++11中最小垃圾回收支持的历史来源

- 要保证安全的垃圾回收，首先要知道C/C++中什么样的行为可能导致不安全的情况
- C++中垃圾回收的不安全性来自于C/C++中指针的过分灵活的使用【代码清单5-10】
  * 对指针p进行自加和自减操作，在这个过程中，垃圾回收器可能认为p原来指向的地址不再使用而将其回收
  * 此时，再次访问已被释放的对象，带来的结果会是灾难性的

- 再看一个例子【代码清单5-11】
  * 先用指针q通过异或运算隐藏指针p，然后再利用异或运算的可逆性恢复指针p，在这个过程中，指针p指向的内存空间可能已被回收了
  * 这时，再使用指针p就会引起灾难性的后果

- 指针的灵活使用可能是C/C++的一大优势，但对于垃圾回收来说，却带来了很大困扰
  * 被隐藏的指针会导致编译器在分析指针的可达性（生命周期）时出错
  * 即使编译器能够正确分析隐藏的指针，对被隐藏的指针进行分析却可能带来编译时间的延长，程序员不会对此视而不见
- 解决这类问题的办法通常是增加新接口，C++11也不例外，让程序员通过这样的接口来提示编译器那些存在不安全指针的代码区域

5、C++11与最小垃圾回收支持

- 为了做到最小垃圾回收支持，C++11首先对安全指针做出了定义，或者使用C++11的术语叫“安全派生”的指针
- 安全派生的指针是指向由new分配的对象或其子对象的指针
- 安全派生指针的操作
  * 在解引用基础上的引用，比如&*p
  * 明确的指针操作，比如p + 1
  * 明确的指针转换，比如static_cast<void*>(p)
  * 指针和整型之间的reinterpret_cast，比如reinterpret_cast<intptr_t>(p)，而前面例子中对reinterpret_cast之后的指针再进行异或操作，就不属于安全派生操作了

-------------------------------------------------------------------------------------------
- intptr_t是C++11中一个可选择实现的类型，其大小等于平台下指针的大小，通过decltype来声明
-------------------------------------------------------------------------------------------

- C++11的最小垃圾回收支持是基于安全派生指针这个概念的，通过函数get_pointer_safety可以查询编译器是否支持这个特性
  * 如果返回值为pointer_safety::strict，则表明编译器支持最小垃圾回收
  * 如果返回值为pointer_safety::relax或者pointer_safety::preferred，则表明编译器并不支持最小垃圾回收，基本上和没有垃圾回收的C和C++98一样，不过前者表明垃圾回收器可能被用作一些辅助功能，比如内存泄漏检测
- 在本书编写时，几乎没有编译器实现了最小垃圾回收支持，甚至连get_pointer_safety这样的函数接口都还没实现

- 如果程序中出现了不安全的指针使用，C++允许程序员通过一些API通知垃圾回收器不要回收该内存
  * declare_reachable：显式地通知垃圾回收器某个对象应该被认为是可达的，即使它的所有指针都对垃圾回收器不可见
  * undeclare_reachable：取消可达声明
- 一个对隐藏指针进行声明的例子【代码清单5-12】
  * declare_reachable和undeclare_reachable实际上确定了一个代码范围，在该范围内垃圾回收器不会对指针进行回收
  * declare_reachable只接受一个简单的void*指针，undeclare_reachable则被设计为一个函数模板，这是为了能够返回合适的类型供程序使用

- 与declare_reachable和undeclare_reachable类似，declare_no_pinters和undeclare_no_pointers用来告诉垃圾回收器在从指针p开始的连续n个对象的范围中不需要进行垃圾回收

6、垃圾回收的兼容性

- 尽管在设计C++11标准时想尽可能保证向后兼容，但对于垃圾回收来说，破坏向后兼容是在所难免的，想让旧的代码毫不费力地使用垃圾回收，在现实情况下还是不可能的
- 此外，C++11对垃圾回收的支持仅限于系统的new操作符分配的内存，对于mallc分配的内存则会被认为总是可达的，无论何时垃圾回收器都不会予以回收
- C++标准的发展以及垃圾回收在C/C++中的实现可能还需要一段时间，不过有了最小支持后，用户可以在新代码中注意指针的使用，对被隐藏指针的堆对象进行保护，在将来C++对垃圾回收的支持完成时，就可以直接享受其带来的益处

三、小结

- C++是一种静态类型的语言
  * 一系列的改进使得C++的类型机制几乎滴水不漏
  * 在C++11中，最后的漏网之鱼，枚举，终于以强类型枚举的方式进入了规范
  * 虽然为了兼容性，旧的枚举语义没有改变，但新的强类型枚举可以避免形如名字冲突、隐式整型转换等诸多问题

- 在堆上分配的内存的释放问题从来都是编程者津津乐道的问题
  * 在C++98中，可以使用智能指针auto_ptr来自动释放内存
  * C++11进一步改进了auto_ptr，程序员可以通过行为更好的unique_ptr、shared_ptr和weak_ptr来进行自动的堆内存释放

- 随着编程模型的复杂化，C++也在考虑引入全面的垃圾回收机制
  * 不过，C++11中仅提供了最小化的垃圾回收支持，定义了什么样的指针对于垃圾回收是安全的以及什么样的操作会对垃圾回收产生影响
  * 一旦出现会对垃圾回收产生影响的操作，程序员可以通过调用API来通知垃圾回收器某个对象是否可达
  * 在现有情况下，这种最小化的垃圾回收支持还没有实质应用，大多数编译器还没有实现相关的内容
  * 不排除以后有编译器或者库的作者设计出能够实现垃圾回收的产品，这还需要假以时日

<2022-9-30>
